% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/qdc.R
\name{QDC}
\alias{QDC}
\alias{qdc}
\title{Quick Density Clustering (QDC): identifying clusters of different densities for geolocated points}
\usage{
QDC(data_sf, sample_size, nclust = 3, k = 10, eps = 0.05)

qdc(data_sf, sample_size, nclust = 3, k = 10, eps = 0.05)
}
\arguments{
\item{data_sf}{Object in \code{sf} or the \code{data.frame} class - in the case of a \code{data.frame} object, the first and second columns must contain X and Y coordinates.}

\item{sample_size}{Sample size, must be less than or equal to the number of points in the dataset (\code{data_sf} parameter).
If \code{sample_size} is larger, it is automatically set to the number of points in the dataset.}

\item{nclust}{Number of clusters to find. Must be >=2. For nclust=3 additional cluster labels are included in the output object.}

\item{k}{Number of nearest neighbours used to calculate the total distance. The default value is k=10.}

\item{eps}{Radius for counting neighbours, fixed value for all observations. The default value is eps=0.05.
This is approximately 5 km for points in the WGS84 projection.}
}
\value{
\code{QDC()} returns two visualisations:
\itemize{
\item Scatter plot of both spatial variables coloured as clusters
\item Location of spatial points coloured according to cluster membership.
}

\code{QDC()} returns also a data.frame object containing the following columns:
\item{X}{original X coordinates}
\item{Y}{original Y coordinates}
\item{knndist1}{total distance to k nearest neighbours}
\item{frnn1}{number of nearest neighbours with fixed radius}
\item{knndist1.scaled}{spatial variable knndist1 after normalisation}
\item{frnn1.scaled}{spatial variable frnn1 after normalisation}
\item{km.set1}{cluster ID of the observation, from the K-means algorithm}
\item{outcome.set1}{cluster labels, only if k=3}
}
\description{
Quick Density Clustering (QDC) uses two spatial variables - the total distance to k nearest neighbours
and the number of neighbours within a fixed radius (\code{eps}). Both spatial variables are normalised
and clustered using the K-means algorithm. Clusters separate points with different local densities.
The function allows sampling to speed up the calculations.
}
\details{
This algorithm is an alternative to DBSCAN. It has no problem with parameterisation, especially in the case of sampling -
it gives a robust solution. It uses K-means, but unlike most algorithms - it does not cluster spatial coordinates,
but pre-prepared normalised spatial variables: total distance to k nearest neighbours and number of neighbours
within a fixed radius (\code{eps}). Its logic is simple: densely located points have a low total distance to \code{knn} points,
while the number of points within a given radius is high. Sparsely located points, on the other hand, have a high total distance
to \code{knn} points, while the number of nearest neighbours within a given radius is low. Both variables are self-scaling
after normalisation and easily show what is high or low. K-means clustering naturally separates groups with similar values
of both spatial variables. There is a non-linear relationship between the two spatial variables, visible in the output Figure 1.
K-means clustering easily finds thresholds of both variables that separate clusters.

The algorithm is robust to sampling. Limiting the size of the data set speeds up the computation. The parameter \code{sample_size} allows to find
the best relation between quality and computation time.
}
\examples{
qdc<-QDC(firms_sf, 5000, nclust=3, k=10, eps=0.05)
qdc

}
\references{
Kopczewska K., (under review), QDC: Quick Density Clustering of Geo-located Data
}
